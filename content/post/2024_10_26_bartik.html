---
title: Bartik Instrument and Rotemberg weights
author: Xiang Ao
date: 2024-10-26
tags: R
categories:
- R

---



<div id="bartik-instrument" class="section level1">
<h1>Bartik Instrument</h1>
<p>Bartik instrument is a method to estimate the causal effect of a treatment on an outcome. The method is developed by Bartik (1991). The method is also known as the shift share IV method.</p>
<p>We follow Goldsmith-Pinkham, Sorkin, and Swift (2021) (GPSS) to describe the method. Let’s say we are interested in estimating the elasiticity of employment on wage growth.</p>
<p><span class="math display">\[ y_{lt} = D_{lt} \rho + \beta_0 x_{lt} + \epsilon_{lt}\]</span></p>
<p><span class="math inline">\(y_l\)</span> is the wage growth in location <span class="math inline">\(l\)</span>, <span class="math inline">\(x_l\)</span> is the employment growth rate. <span class="math inline">\(\beta_0\)</span> is the inverse elasticity of labor supply.</p>
<p>The usual challenge is that <span class="math inline">\(x_l\)</span> is endogenous. There could be factors that are driving both wage growth and employment growth at location <span class="math inline">\(l\)</span>. Note that I am omitting the time subscript for simplicity.</p>
<p>There are two accounting identities:</p>
<p><span class="math display">\[ x_{lt} = Z_{lt} G_{lt} = \sum_{k=1}^K z_{lkt} g_{lkt} \]</span>
and
<span class="math display">\[ g_{lkt} = g_{kt} + \tilde{g}_{lkt} \]</span></p>
<p>Suppose in location <span class="math inline">\(l\)</span> there are <span class="math inline">\(K\)</span> industries. Then the employment growth can be decomposed to the sum of industry growth <span class="math inline">\(g_{lkt}\)</span>, with <span class="math inline">\(z\)</span>’s as the industry shares.</p>
<p>The second identity is to say the this industry growh rate at this location can be decomposed to a national industry rate and a location-industry rate. The idea of Bartik instrument is to use the product of initial industry location share and industry growth rate as the instrument.</p>
<p><span class="math display">\[ B_{lt} = Z_{l0} G_{t} = \sum_{k=1}^K z_{lk0} g_{kt} \]</span></p>
<p>The intuition is that the initial shares are exogenous, as it’s a level variable. And the industry growth rate is exogenous, since it’s national, not location related.</p>
</div>
<div id="bartik-instrument-in-special-cases" class="section level1">
<h1>Bartik Instrument in special cases</h1>
<div id="two-industries-and-one-period" class="section level2">
<h2>Two industries and one period</h2>
<p>GPSS goes through the simpliest case: two industries and one period.</p>
<p><span class="math display">\[ B_l = z_{l1} g_1 + z_{l2} g_2 \]</span></p>
<p>Since there are only two industries, <span class="math inline">\(z_{l1} = 1 - z_{l2}\)</span>. Then we can rewrite the Bartik instrument as</p>
<p><span class="math display">\[ B_l = g_2 + (g_1 - g_2) z_{l1} \]</span></p>
<p>From this simplist case, we see that the instrument has only <span class="math inline">\(z_{l1}\)</span>, that is related to location. If the industry share can be considered exogenous, then the instrument is valid. We have to argue that the industry share is exogenous. In this case, the instrument is a linear function of the industry share. Therefore, the Bartik instrument is the same as using the industry share as an instrument.</p>
<p>GPSS shows that just-identified two-stage least squares using a Bartik instrument can in fact be written as GMM with an overidentified set of instruments, where the weight matrix is the outer product of national growth rates. That is, Bartik estimator is equivalent to a GMM estimator, with each location share as one instrument, and the weight matrix is the outer product of national growth rates.</p>
<p>With <span class="math inline">\(K\)</span> industries and <span class="math inline">\(T\)</span> time periods, it’s basically using <span class="math inline">\(K \times T\)</span> instruments. Still, Bartik instrument is the same as GMM with all these instruments.</p>
</div>
</div>
<div id="rotemberg-weights" class="section level1">
<h1>Rotemberg weights</h1>
<p>GPSS decompose the Bartik estimator:</p>
<p><span class="math display">\[ \beta_{Bartik} = \sum_{k} \hat \alpha_k \hat \beta_k\]</span>
where
<span class="math display">\[ \hat \beta_k = (Z&#39;_k X^{\perp})^{-1} Z&#39;_k Y^{\perp}\]</span>
and
<span class="math display">\[ \hat \alpha_k = \frac{g_k Z&#39;_k X^{\perp}}{\sum_{k&#39;} g_{k&#39;}  Z&#39;_{k&#39;} X^{\perp}}\]</span></p>
<p>Here <span class="math inline">\(X^{\perp}\)</span> and <span class="math inline">\(Y^{\perp}\)</span> are the residualized <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span>, from the regression of <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> on all other variables (controls).</p>
<p>Rotemberg weights provide a measure of how important each share is. Each weight states how much bias the overall estimate would have if a given instrument (industry) were biased by <span class="math inline">\(\alpha_k\)</span> percent. Weights can be very useful to see which industries are important, and thus whether exogeneity assumptions are plausible for instruments with largest weights.</p>
</div>
<div id="simulations" class="section level1">
<h1>Simulations</h1>
<p>Simulations codes are adopted from Kohei Kawaguchi’s lecture notes. I modified slightly to fit different scenarios.</p>
<p>Here we simulate a case with 4 industries and 4 periods. We have 1000 locations, 4 periods, and 4 industries. The true <span class="math inline">\(\beta\)</span> (effect of <span class="math inline">\(x\)</span> on <span class="math inline">\(y\)</span>) is 1.</p>
<pre class="r"><code>library(ggplot2)
library(tidyverse)
library(modelsummary)
library(kableExtra)
library(estimatr)
set.seed(6)
L &lt;- 1000
T &lt;- 4
K &lt;- 4
beta &lt;- 1
sigma &lt;-c(1, 1, 1)

z_lk0 &lt;- expand_grid(
    l = 1:L,
    k = 1:K
  ) |&gt; 
mutate(z_lk0 = runif(length(l))) 

g_kt &lt;-  expand_grid(
    t = 1:T,
    k = 1:K
  ) |&gt; 
  mutate(g_kt = rnorm(t, 0, .1))

df &lt;- expand_grid(
    l = 1:L,
    t = 1:T,
    k = 1:K
  ) |&gt; 
  left_join(z_lk0, by = c(&quot;l&quot;, &quot;k&quot;)) |&gt; 
  left_join(g_kt,  by = c(&quot;k&quot;, &quot;t&quot;)) |&gt;
  mutate(z_lkt = z_lk0 + sigma[1] * runif(length(l)),
    g_lkt = g_kt + sigma[2] * rnorm(length(l),0, .1)
  ) 

df &lt;- df %&gt;%
  group_by(t, l) |&gt; 
  mutate(
    z_lk0 = z_lk0 / sum(z_lk0),
    z_lkt = (z_lkt / sum(z_lkt)),
    x_lt = sum(z_lkt * g_lkt)
  ) 

df</code></pre>
<pre><code>## # A tibble: 16,000 × 8
## # Groups:   t, l [4,000]
##        l     t     k z_lk0     g_kt z_lkt    g_lkt    x_lt
##    &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt;
##  1     1     1     1 0.277  0.130   0.252  0.115    0.0400
##  2     1     1     2 0.428  0.146   0.302  0.291    0.0400
##  3     1     1     3 0.121 -0.165   0.321 -0.231    0.0400
##  4     1     1     4 0.174 -0.110   0.126 -0.0185   0.0400
##  5     1     2     1 0.277 -0.0289  0.160 -0.00619  0.0402
##  6     1     2     2 0.428 -0.00130 0.356  0.0560   0.0402
##  7     1     2     3 0.121  0.0433  0.272 -0.0590   0.0402
##  8     1     2     4 0.174  0.0840  0.212  0.176    0.0402
##  9     1     3     1 0.277 -0.101   0.237 -0.0361  -0.0738
## 10     1     3     2 0.428 -0.152   0.367 -0.126   -0.0738
## # ℹ 15,990 more rows</code></pre>
<p>This assumes we observe the industry shares at time 0 (<span class="math inline">\(z_{lk0}\)</span>), and the industry growth rates (<span class="math inline">\(g_{kt}\)</span>). We also observe the industry shares at time <span class="math inline">\(t\)</span> (<span class="math inline">\(z_{lkt}\)</span>). The employment growth rate at location <span class="math inline">\(l\)</span> and time <span class="math inline">\(t\)</span> (<span class="math inline">\(g_{lkt}\)</span>) is a function of <span class="math inline">\(g_{kt}\)</span> plus some noise. We can calculate the <span class="math inline">\(x_{lt}\)</span>, which is the weighted sum of industry growth rates.</p>
<p>Next we generate the outcome at <span class="math inline">\(l\)</span>, <span class="math inline">\(t\)</span> level. Outcome (wage growth) is a linear function of <span class="math inline">\(x\)</span> (employment growth) at <span class="math inline">\(l\)</span>, <span class="math inline">\(t\)</span> level.</p>
<pre class="r"><code>df_lt &lt;- df |&gt;
  mutate(g_tilde_lkt = g_lkt - g_kt) |&gt; 
  group_by(l, t) |&gt; 
  summarise(across(c(x_lt, g_tilde_lkt),  mean),  .groups = &quot;drop&quot;) |&gt;
  ungroup() |&gt; 
  mutate(y_lt = beta * x_lt + sigma[3] * g_tilde_lkt)</code></pre>
<p>If we run OLS on raw data, we’ll get biased results.</p>
<pre class="r"><code>result_ols &lt;-
  df_lt |&gt;
  lm(formula = y_lt ~ x_lt)

modelsummary(result_ols)</code></pre>
<!-- preamble start -->

    <script>
      function styleCell_1trj4rjq9zf8xhrqaz6r(i, j, css_id) {
        var table = document.getElementById("tinytable_1trj4rjq9zf8xhrqaz6r");
        table.rows[i].cells[j].classList.add(css_id);
      }
      function insertSpanRow(i, colspan, content) {
        var table = document.getElementById('tinytable_1trj4rjq9zf8xhrqaz6r');
        var newRow = table.insertRow(i);
        var newCell = newRow.insertCell(0);
        newCell.setAttribute("colspan", colspan);
        // newCell.innerText = content;
        // this may be unsafe, but innerText does not interpret <br>
        newCell.innerHTML = content;
      }
      function spanCell_1trj4rjq9zf8xhrqaz6r(i, j, rowspan, colspan) {
        var table = document.getElementById("tinytable_1trj4rjq9zf8xhrqaz6r");
        const targetRow = table.rows[i];
        const targetCell = targetRow.cells[j];
        for (let r = 0; r < rowspan; r++) {
          // Only start deleting cells to the right for the first row (r == 0)
          if (r === 0) {
            // Delete cells to the right of the target cell in the first row
            for (let c = colspan - 1; c > 0; c--) {
              if (table.rows[i + r].cells[j + c]) {
                table.rows[i + r].deleteCell(j + c);
              }
            }
          }
          // For rows below the first, delete starting from the target column
          if (r > 0) {
            for (let c = colspan - 1; c >= 0; c--) {
              if (table.rows[i + r] && table.rows[i + r].cells[j]) {
                table.rows[i + r].deleteCell(j);
              }
            }
          }
        }
        // Set rowspan and colspan of the target cell
        targetCell.rowSpan = rowspan;
        targetCell.colSpan = colspan;
      }
window.addEventListener('load', function () { styleCell_1trj4rjq9zf8xhrqaz6r(0, 0, 'tinytable_css_idl4febg8h9ubm6o2fovqf') })
window.addEventListener('load', function () { styleCell_1trj4rjq9zf8xhrqaz6r(0, 1, 'tinytable_css_idqh4z4ax1ode4se58kwsg') })
window.addEventListener('load', function () { styleCell_1trj4rjq9zf8xhrqaz6r(1, 0, 'tinytable_css_idkrnatzejbkf50uu3g95i') })
window.addEventListener('load', function () { styleCell_1trj4rjq9zf8xhrqaz6r(1, 1, 'tinytable_css_idfct7ajlnvgowzk8j84ij') })
window.addEventListener('load', function () { styleCell_1trj4rjq9zf8xhrqaz6r(2, 0, 'tinytable_css_idkrnatzejbkf50uu3g95i') })
window.addEventListener('load', function () { styleCell_1trj4rjq9zf8xhrqaz6r(2, 1, 'tinytable_css_idfct7ajlnvgowzk8j84ij') })
window.addEventListener('load', function () { styleCell_1trj4rjq9zf8xhrqaz6r(3, 0, 'tinytable_css_idkrnatzejbkf50uu3g95i') })
window.addEventListener('load', function () { styleCell_1trj4rjq9zf8xhrqaz6r(3, 1, 'tinytable_css_idfct7ajlnvgowzk8j84ij') })
window.addEventListener('load', function () { styleCell_1trj4rjq9zf8xhrqaz6r(4, 0, 'tinytable_css_idnqj8v7v6h7ii1ectard8') })
window.addEventListener('load', function () { styleCell_1trj4rjq9zf8xhrqaz6r(4, 1, 'tinytable_css_idt5v4lihbimsh83z6htup') })
window.addEventListener('load', function () { styleCell_1trj4rjq9zf8xhrqaz6r(5, 0, 'tinytable_css_idkrnatzejbkf50uu3g95i') })
window.addEventListener('load', function () { styleCell_1trj4rjq9zf8xhrqaz6r(5, 1, 'tinytable_css_idfct7ajlnvgowzk8j84ij') })
window.addEventListener('load', function () { styleCell_1trj4rjq9zf8xhrqaz6r(6, 0, 'tinytable_css_idkrnatzejbkf50uu3g95i') })
window.addEventListener('load', function () { styleCell_1trj4rjq9zf8xhrqaz6r(6, 1, 'tinytable_css_idfct7ajlnvgowzk8j84ij') })
window.addEventListener('load', function () { styleCell_1trj4rjq9zf8xhrqaz6r(7, 0, 'tinytable_css_idkrnatzejbkf50uu3g95i') })
window.addEventListener('load', function () { styleCell_1trj4rjq9zf8xhrqaz6r(7, 1, 'tinytable_css_idfct7ajlnvgowzk8j84ij') })
window.addEventListener('load', function () { styleCell_1trj4rjq9zf8xhrqaz6r(8, 0, 'tinytable_css_idkrnatzejbkf50uu3g95i') })
window.addEventListener('load', function () { styleCell_1trj4rjq9zf8xhrqaz6r(8, 1, 'tinytable_css_idfct7ajlnvgowzk8j84ij') })
window.addEventListener('load', function () { styleCell_1trj4rjq9zf8xhrqaz6r(9, 0, 'tinytable_css_idkrnatzejbkf50uu3g95i') })
window.addEventListener('load', function () { styleCell_1trj4rjq9zf8xhrqaz6r(9, 1, 'tinytable_css_idfct7ajlnvgowzk8j84ij') })
window.addEventListener('load', function () { styleCell_1trj4rjq9zf8xhrqaz6r(10, 0, 'tinytable_css_idkrnatzejbkf50uu3g95i') })
window.addEventListener('load', function () { styleCell_1trj4rjq9zf8xhrqaz6r(10, 1, 'tinytable_css_idfct7ajlnvgowzk8j84ij') })
window.addEventListener('load', function () { styleCell_1trj4rjq9zf8xhrqaz6r(11, 0, 'tinytable_css_idkrnatzejbkf50uu3g95i') })
window.addEventListener('load', function () { styleCell_1trj4rjq9zf8xhrqaz6r(11, 1, 'tinytable_css_idfct7ajlnvgowzk8j84ij') })
window.addEventListener('load', function () { styleCell_1trj4rjq9zf8xhrqaz6r(12, 0, 'tinytable_css_idkrnatzejbkf50uu3g95i') })
window.addEventListener('load', function () { styleCell_1trj4rjq9zf8xhrqaz6r(12, 1, 'tinytable_css_idfct7ajlnvgowzk8j84ij') })
    </script>

    <style>
    .table td.tinytable_css_idl4febg8h9ubm6o2fovqf, .table th.tinytable_css_idl4febg8h9ubm6o2fovqf {  text-align: left;  border-bottom: solid 0.1em #d3d8dc; }
    .table td.tinytable_css_idqh4z4ax1ode4se58kwsg, .table th.tinytable_css_idqh4z4ax1ode4se58kwsg {  text-align: center;  border-bottom: solid 0.1em #d3d8dc; }
    .table td.tinytable_css_idkrnatzejbkf50uu3g95i, .table th.tinytable_css_idkrnatzejbkf50uu3g95i {  text-align: left; }
    .table td.tinytable_css_idfct7ajlnvgowzk8j84ij, .table th.tinytable_css_idfct7ajlnvgowzk8j84ij {  text-align: center; }
    .table td.tinytable_css_idnqj8v7v6h7ii1ectard8, .table th.tinytable_css_idnqj8v7v6h7ii1ectard8 {  border-bottom: solid 0.05em black;  text-align: left; }
    .table td.tinytable_css_idt5v4lihbimsh83z6htup, .table th.tinytable_css_idt5v4lihbimsh83z6htup {  border-bottom: solid 0.05em black;  text-align: center; }
    </style>
    <div class="container">
      <table class="table table-borderless" id="tinytable_1trj4rjq9zf8xhrqaz6r" style="width: auto; margin-left: auto; margin-right: auto;" data-quarto-disable-processing='true'>
        <thead>
        
              <tr>
                <th scope="col"> </th>
                <th scope="col">(1)</th>
              </tr>
        </thead>
        
        <tbody>
                <tr>
                  <td>(Intercept)</td>
                  <td>0.000    </td>
                </tr>
                <tr>
                  <td>           </td>
                  <td>(0.001)  </td>
                </tr>
                <tr>
                  <td>x_lt       </td>
                  <td>1.336    </td>
                </tr>
                <tr>
                  <td>           </td>
                  <td>(0.008)  </td>
                </tr>
                <tr>
                  <td>Num.Obs.   </td>
                  <td>4000     </td>
                </tr>
                <tr>
                  <td>R2         </td>
                  <td>0.884    </td>
                </tr>
                <tr>
                  <td>R2 Adj.    </td>
                  <td>0.884    </td>
                </tr>
                <tr>
                  <td>AIC        </td>
                  <td>-14059.9 </td>
                </tr>
                <tr>
                  <td>BIC        </td>
                  <td>-14041.0 </td>
                </tr>
                <tr>
                  <td>Log.Lik.   </td>
                  <td>7032.945 </td>
                </tr>
                <tr>
                  <td>F          </td>
                  <td>30603.441</td>
                </tr>
                <tr>
                  <td>RMSE       </td>
                  <td>0.04     </td>
                </tr>
        </tbody>
      </table>
    </div>
<!-- hack to avoid NA insertion in last line -->
<p>Now we generate the Bartik instrument. We calculate the Bartik instrument as the weighted sum of <span class="math inline">\(z_{lk0}\)</span> and <span class="math inline">\(g_{kt}\)</span>.</p>
<pre class="r"><code>b_lt &lt;- df |&gt; 
  group_by(l, t) |&gt;
  summarise(b_lt = sum(z_lk0 * g_kt)) |&gt;
  ungroup()

df_lt &lt;- df_lt |&gt;
  left_join(b_lt, by = c(&quot;l&quot;, &quot;t&quot;))


result_first_stage &lt;-  lm(formula = x_lt ~ b_lt, data = df_lt)

modelsummary(result_first_stage)</code></pre>
<!-- preamble start -->

    <script>
      function styleCell_vltpsc7vf7oi54cz1uuq(i, j, css_id) {
        var table = document.getElementById("tinytable_vltpsc7vf7oi54cz1uuq");
        table.rows[i].cells[j].classList.add(css_id);
      }
      function insertSpanRow(i, colspan, content) {
        var table = document.getElementById('tinytable_vltpsc7vf7oi54cz1uuq');
        var newRow = table.insertRow(i);
        var newCell = newRow.insertCell(0);
        newCell.setAttribute("colspan", colspan);
        // newCell.innerText = content;
        // this may be unsafe, but innerText does not interpret <br>
        newCell.innerHTML = content;
      }
      function spanCell_vltpsc7vf7oi54cz1uuq(i, j, rowspan, colspan) {
        var table = document.getElementById("tinytable_vltpsc7vf7oi54cz1uuq");
        const targetRow = table.rows[i];
        const targetCell = targetRow.cells[j];
        for (let r = 0; r < rowspan; r++) {
          // Only start deleting cells to the right for the first row (r == 0)
          if (r === 0) {
            // Delete cells to the right of the target cell in the first row
            for (let c = colspan - 1; c > 0; c--) {
              if (table.rows[i + r].cells[j + c]) {
                table.rows[i + r].deleteCell(j + c);
              }
            }
          }
          // For rows below the first, delete starting from the target column
          if (r > 0) {
            for (let c = colspan - 1; c >= 0; c--) {
              if (table.rows[i + r] && table.rows[i + r].cells[j]) {
                table.rows[i + r].deleteCell(j);
              }
            }
          }
        }
        // Set rowspan and colspan of the target cell
        targetCell.rowSpan = rowspan;
        targetCell.colSpan = colspan;
      }
window.addEventListener('load', function () { styleCell_vltpsc7vf7oi54cz1uuq(0, 0, 'tinytable_css_idq95iegji1hwc51tmmnig') })
window.addEventListener('load', function () { styleCell_vltpsc7vf7oi54cz1uuq(0, 1, 'tinytable_css_idox8jgdv5di8g9yjikcr5') })
window.addEventListener('load', function () { styleCell_vltpsc7vf7oi54cz1uuq(1, 0, 'tinytable_css_idb1va8btzxlnpagusx8df') })
window.addEventListener('load', function () { styleCell_vltpsc7vf7oi54cz1uuq(1, 1, 'tinytable_css_iddzewyn03rop8pgjl8dv4') })
window.addEventListener('load', function () { styleCell_vltpsc7vf7oi54cz1uuq(2, 0, 'tinytable_css_idb1va8btzxlnpagusx8df') })
window.addEventListener('load', function () { styleCell_vltpsc7vf7oi54cz1uuq(2, 1, 'tinytable_css_iddzewyn03rop8pgjl8dv4') })
window.addEventListener('load', function () { styleCell_vltpsc7vf7oi54cz1uuq(3, 0, 'tinytable_css_idb1va8btzxlnpagusx8df') })
window.addEventListener('load', function () { styleCell_vltpsc7vf7oi54cz1uuq(3, 1, 'tinytable_css_iddzewyn03rop8pgjl8dv4') })
window.addEventListener('load', function () { styleCell_vltpsc7vf7oi54cz1uuq(4, 0, 'tinytable_css_idto3zrttae22mq7vc23j8') })
window.addEventListener('load', function () { styleCell_vltpsc7vf7oi54cz1uuq(4, 1, 'tinytable_css_idqqsc75wo4y35b1yknjf6') })
window.addEventListener('load', function () { styleCell_vltpsc7vf7oi54cz1uuq(5, 0, 'tinytable_css_idb1va8btzxlnpagusx8df') })
window.addEventListener('load', function () { styleCell_vltpsc7vf7oi54cz1uuq(5, 1, 'tinytable_css_iddzewyn03rop8pgjl8dv4') })
window.addEventListener('load', function () { styleCell_vltpsc7vf7oi54cz1uuq(6, 0, 'tinytable_css_idb1va8btzxlnpagusx8df') })
window.addEventListener('load', function () { styleCell_vltpsc7vf7oi54cz1uuq(6, 1, 'tinytable_css_iddzewyn03rop8pgjl8dv4') })
window.addEventListener('load', function () { styleCell_vltpsc7vf7oi54cz1uuq(7, 0, 'tinytable_css_idb1va8btzxlnpagusx8df') })
window.addEventListener('load', function () { styleCell_vltpsc7vf7oi54cz1uuq(7, 1, 'tinytable_css_iddzewyn03rop8pgjl8dv4') })
window.addEventListener('load', function () { styleCell_vltpsc7vf7oi54cz1uuq(8, 0, 'tinytable_css_idb1va8btzxlnpagusx8df') })
window.addEventListener('load', function () { styleCell_vltpsc7vf7oi54cz1uuq(8, 1, 'tinytable_css_iddzewyn03rop8pgjl8dv4') })
window.addEventListener('load', function () { styleCell_vltpsc7vf7oi54cz1uuq(9, 0, 'tinytable_css_idb1va8btzxlnpagusx8df') })
window.addEventListener('load', function () { styleCell_vltpsc7vf7oi54cz1uuq(9, 1, 'tinytable_css_iddzewyn03rop8pgjl8dv4') })
window.addEventListener('load', function () { styleCell_vltpsc7vf7oi54cz1uuq(10, 0, 'tinytable_css_idb1va8btzxlnpagusx8df') })
window.addEventListener('load', function () { styleCell_vltpsc7vf7oi54cz1uuq(10, 1, 'tinytable_css_iddzewyn03rop8pgjl8dv4') })
window.addEventListener('load', function () { styleCell_vltpsc7vf7oi54cz1uuq(11, 0, 'tinytable_css_idb1va8btzxlnpagusx8df') })
window.addEventListener('load', function () { styleCell_vltpsc7vf7oi54cz1uuq(11, 1, 'tinytable_css_iddzewyn03rop8pgjl8dv4') })
window.addEventListener('load', function () { styleCell_vltpsc7vf7oi54cz1uuq(12, 0, 'tinytable_css_idb1va8btzxlnpagusx8df') })
window.addEventListener('load', function () { styleCell_vltpsc7vf7oi54cz1uuq(12, 1, 'tinytable_css_iddzewyn03rop8pgjl8dv4') })
    </script>

    <style>
    .table td.tinytable_css_idq95iegji1hwc51tmmnig, .table th.tinytable_css_idq95iegji1hwc51tmmnig {  text-align: left;  border-bottom: solid 0.1em #d3d8dc; }
    .table td.tinytable_css_idox8jgdv5di8g9yjikcr5, .table th.tinytable_css_idox8jgdv5di8g9yjikcr5 {  text-align: center;  border-bottom: solid 0.1em #d3d8dc; }
    .table td.tinytable_css_idb1va8btzxlnpagusx8df, .table th.tinytable_css_idb1va8btzxlnpagusx8df {  text-align: left; }
    .table td.tinytable_css_iddzewyn03rop8pgjl8dv4, .table th.tinytable_css_iddzewyn03rop8pgjl8dv4 {  text-align: center; }
    .table td.tinytable_css_idto3zrttae22mq7vc23j8, .table th.tinytable_css_idto3zrttae22mq7vc23j8 {  border-bottom: solid 0.05em black;  text-align: left; }
    .table td.tinytable_css_idqqsc75wo4y35b1yknjf6, .table th.tinytable_css_idqqsc75wo4y35b1yknjf6 {  border-bottom: solid 0.05em black;  text-align: center; }
    </style>
    <div class="container">
      <table class="table table-borderless" id="tinytable_vltpsc7vf7oi54cz1uuq" style="width: auto; margin-left: auto; margin-right: auto;" data-quarto-disable-processing='true'>
        <thead>
        
              <tr>
                <th scope="col"> </th>
                <th scope="col">(1)</th>
              </tr>
        </thead>
        
        <tbody>
                <tr>
                  <td>(Intercept)</td>
                  <td>-0.001  </td>
                </tr>
                <tr>
                  <td>           </td>
                  <td>(0.001) </td>
                </tr>
                <tr>
                  <td>b_lt       </td>
                  <td>0.919   </td>
                </tr>
                <tr>
                  <td>           </td>
                  <td>(0.013) </td>
                </tr>
                <tr>
                  <td>Num.Obs.   </td>
                  <td>4000    </td>
                </tr>
                <tr>
                  <td>R2         </td>
                  <td>0.573   </td>
                </tr>
                <tr>
                  <td>R2 Adj.    </td>
                  <td>0.573   </td>
                </tr>
                <tr>
                  <td>AIC        </td>
                  <td>-11638.5</td>
                </tr>
                <tr>
                  <td>BIC        </td>
                  <td>-11619.6</td>
                </tr>
                <tr>
                  <td>Log.Lik.   </td>
                  <td>5822.262</td>
                </tr>
                <tr>
                  <td>F          </td>
                  <td>5361.487</td>
                </tr>
                <tr>
                  <td>RMSE       </td>
                  <td>0.06    </td>
                </tr>
        </tbody>
      </table>
    </div>
<!-- hack to avoid NA insertion in last line -->
<pre class="r"><code>result_tsls &lt;- df_lt |&gt;
  estimatr::iv_robust(formula = y_lt ~ x_lt | b_lt)

modelsummary::modelsummary(result_tsls)</code></pre>
<!-- preamble start -->

    <script>
      function styleCell_jebzejnigew36vs8ts3l(i, j, css_id) {
        var table = document.getElementById("tinytable_jebzejnigew36vs8ts3l");
        table.rows[i].cells[j].classList.add(css_id);
      }
      function insertSpanRow(i, colspan, content) {
        var table = document.getElementById('tinytable_jebzejnigew36vs8ts3l');
        var newRow = table.insertRow(i);
        var newCell = newRow.insertCell(0);
        newCell.setAttribute("colspan", colspan);
        // newCell.innerText = content;
        // this may be unsafe, but innerText does not interpret <br>
        newCell.innerHTML = content;
      }
      function spanCell_jebzejnigew36vs8ts3l(i, j, rowspan, colspan) {
        var table = document.getElementById("tinytable_jebzejnigew36vs8ts3l");
        const targetRow = table.rows[i];
        const targetCell = targetRow.cells[j];
        for (let r = 0; r < rowspan; r++) {
          // Only start deleting cells to the right for the first row (r == 0)
          if (r === 0) {
            // Delete cells to the right of the target cell in the first row
            for (let c = colspan - 1; c > 0; c--) {
              if (table.rows[i + r].cells[j + c]) {
                table.rows[i + r].deleteCell(j + c);
              }
            }
          }
          // For rows below the first, delete starting from the target column
          if (r > 0) {
            for (let c = colspan - 1; c >= 0; c--) {
              if (table.rows[i + r] && table.rows[i + r].cells[j]) {
                table.rows[i + r].deleteCell(j);
              }
            }
          }
        }
        // Set rowspan and colspan of the target cell
        targetCell.rowSpan = rowspan;
        targetCell.colSpan = colspan;
      }
window.addEventListener('load', function () { styleCell_jebzejnigew36vs8ts3l(0, 0, 'tinytable_css_idfhz241cepy2e5o2o3x5c') })
window.addEventListener('load', function () { styleCell_jebzejnigew36vs8ts3l(0, 1, 'tinytable_css_id0po9biq3ykmgz7fdw659') })
window.addEventListener('load', function () { styleCell_jebzejnigew36vs8ts3l(1, 0, 'tinytable_css_id9ef62yaafp6asv1vpsiy') })
window.addEventListener('load', function () { styleCell_jebzejnigew36vs8ts3l(1, 1, 'tinytable_css_idnl3bekowpvf38gjoia5v') })
window.addEventListener('load', function () { styleCell_jebzejnigew36vs8ts3l(2, 0, 'tinytable_css_id9ef62yaafp6asv1vpsiy') })
window.addEventListener('load', function () { styleCell_jebzejnigew36vs8ts3l(2, 1, 'tinytable_css_idnl3bekowpvf38gjoia5v') })
window.addEventListener('load', function () { styleCell_jebzejnigew36vs8ts3l(3, 0, 'tinytable_css_id9ef62yaafp6asv1vpsiy') })
window.addEventListener('load', function () { styleCell_jebzejnigew36vs8ts3l(3, 1, 'tinytable_css_idnl3bekowpvf38gjoia5v') })
window.addEventListener('load', function () { styleCell_jebzejnigew36vs8ts3l(4, 0, 'tinytable_css_idrkg2d1w296edri312mao') })
window.addEventListener('load', function () { styleCell_jebzejnigew36vs8ts3l(4, 1, 'tinytable_css_id4vyfly6pwhqo9e615qts') })
window.addEventListener('load', function () { styleCell_jebzejnigew36vs8ts3l(5, 0, 'tinytable_css_id9ef62yaafp6asv1vpsiy') })
window.addEventListener('load', function () { styleCell_jebzejnigew36vs8ts3l(5, 1, 'tinytable_css_idnl3bekowpvf38gjoia5v') })
window.addEventListener('load', function () { styleCell_jebzejnigew36vs8ts3l(6, 0, 'tinytable_css_id9ef62yaafp6asv1vpsiy') })
window.addEventListener('load', function () { styleCell_jebzejnigew36vs8ts3l(6, 1, 'tinytable_css_idnl3bekowpvf38gjoia5v') })
window.addEventListener('load', function () { styleCell_jebzejnigew36vs8ts3l(7, 0, 'tinytable_css_id9ef62yaafp6asv1vpsiy') })
window.addEventListener('load', function () { styleCell_jebzejnigew36vs8ts3l(7, 1, 'tinytable_css_idnl3bekowpvf38gjoia5v') })
window.addEventListener('load', function () { styleCell_jebzejnigew36vs8ts3l(8, 0, 'tinytable_css_id9ef62yaafp6asv1vpsiy') })
window.addEventListener('load', function () { styleCell_jebzejnigew36vs8ts3l(8, 1, 'tinytable_css_idnl3bekowpvf38gjoia5v') })
window.addEventListener('load', function () { styleCell_jebzejnigew36vs8ts3l(9, 0, 'tinytable_css_id9ef62yaafp6asv1vpsiy') })
window.addEventListener('load', function () { styleCell_jebzejnigew36vs8ts3l(9, 1, 'tinytable_css_idnl3bekowpvf38gjoia5v') })
window.addEventListener('load', function () { styleCell_jebzejnigew36vs8ts3l(10, 0, 'tinytable_css_id9ef62yaafp6asv1vpsiy') })
window.addEventListener('load', function () { styleCell_jebzejnigew36vs8ts3l(10, 1, 'tinytable_css_idnl3bekowpvf38gjoia5v') })
    </script>

    <style>
    .table td.tinytable_css_idfhz241cepy2e5o2o3x5c, .table th.tinytable_css_idfhz241cepy2e5o2o3x5c {  text-align: left;  border-bottom: solid 0.1em #d3d8dc; }
    .table td.tinytable_css_id0po9biq3ykmgz7fdw659, .table th.tinytable_css_id0po9biq3ykmgz7fdw659 {  text-align: center;  border-bottom: solid 0.1em #d3d8dc; }
    .table td.tinytable_css_id9ef62yaafp6asv1vpsiy, .table th.tinytable_css_id9ef62yaafp6asv1vpsiy {  text-align: left; }
    .table td.tinytable_css_idnl3bekowpvf38gjoia5v, .table th.tinytable_css_idnl3bekowpvf38gjoia5v {  text-align: center; }
    .table td.tinytable_css_idrkg2d1w296edri312mao, .table th.tinytable_css_idrkg2d1w296edri312mao {  border-bottom: solid 0.05em black;  text-align: left; }
    .table td.tinytable_css_id4vyfly6pwhqo9e615qts, .table th.tinytable_css_id4vyfly6pwhqo9e615qts {  border-bottom: solid 0.05em black;  text-align: center; }
    </style>
    <div class="container">
      <table class="table table-borderless" id="tinytable_jebzejnigew36vs8ts3l" style="width: auto; margin-left: auto; margin-right: auto;" data-quarto-disable-processing='true'>
        <thead>
        
              <tr>
                <th scope="col"> </th>
                <th scope="col">(1)</th>
              </tr>
        </thead>
        
        <tbody>
                <tr>
                  <td>(Intercept)</td>
                  <td>0.000   </td>
                </tr>
                <tr>
                  <td>           </td>
                  <td>(0.001) </td>
                </tr>
                <tr>
                  <td>x_lt       </td>
                  <td>0.990   </td>
                </tr>
                <tr>
                  <td>           </td>
                  <td>(0.012) </td>
                </tr>
                <tr>
                  <td>Num.Obs.   </td>
                  <td>4000    </td>
                </tr>
                <tr>
                  <td>R2         </td>
                  <td>0.825   </td>
                </tr>
                <tr>
                  <td>R2 Adj.    </td>
                  <td>0.825   </td>
                </tr>
                <tr>
                  <td>AIC        </td>
                  <td>-12398.4</td>
                </tr>
                <tr>
                  <td>BIC        </td>
                  <td>-12379.5</td>
                </tr>
                <tr>
                  <td>RMSE       </td>
                  <td>0.05    </td>
                </tr>
        </tbody>
      </table>
    </div>
<!-- hack to avoid NA insertion in last line -->
<div id="calculate-rotemberg-weights" class="section level2">
<h2>Calculate Rotemberg weights</h2>
<p>Let’s do IV using Bartik instruments. No controls here. We use matrix operation to recover the IV estimates, which is the same as the tsls function in R.</p>
<pre class="r"><code>B = as.matrix(cbind(1,df_lt$b_lt))
Y = as.matrix(df_lt$y_lt)
X = as.matrix(cbind(1,df_lt$x_lt))
 
iv = round(solve(t(B)%*%X)%*%t(B)%*%Y,3)
 
## Label and organize results into a data frame
beta.hat = as.data.frame(cbind(c(&quot;Intercept&quot;,&quot;x&quot;),iv))
names(beta.hat) = c(&quot;Coeff.&quot;,&quot;Est&quot;)
beta.hat</code></pre>
<pre><code>##      Coeff.  Est
## 1 Intercept    0
## 2         x 0.99</code></pre>
<p>Now we calculate the Rotemberg weights.</p>
<pre class="r"><code># This code is the R version of Paul Goldsmith-Pinkham&#39;s R code for Rotemberg weights on 
# github; which is actually a call from a C++ code by jjchern.
# bw.R calls ComputeAlphaBeta.cpp
# dimensions:  G is KTx1, Z is LTxKT, Y is LTx1, X is LTx1
# so B=ZG is LTx1
# Here I learned the dimensions from the ADH example in Paul&#39;s github.
# in ADH example, czone(L) is 722, year(T) is 2, ind(K) is 390.
# so G is 780x1, Z is 1444x780, Y is 1444x1, X is 1444x1
y_lt &lt;- df_lt |&gt; 
  select(l,t,y_lt)

Y &lt;- as.matrix(y_lt[,3])

x_lt &lt;- df_lt |&gt; 
  select(l,t,x_lt)

X &lt;- as.matrix(x_lt[,3])
#X &lt;- as.matrix(cbind(1,x_lt[,3]))

# global is kt level data set
# # g_data &lt;- df |&gt; 
# #   group_by(k,t) |&gt; 
# #   summarise(g_kt=sum(g_lkt*z_lkt)) 
# 
# G &lt;- as.matrix(g_data[,3])

G &lt;- as.matrix(g_kt[,3])

# generate wide Z matrix, LTxKT from df
# z_data &lt;- df |&gt; 
#   select(l,t,k,z_lkt) |&gt; 
#   pivot_wider(names_from = k, values_from = z_lkt) |&gt; 
#   select(-l, -t)

# this makes a wide Z data, which is LTxKT, KT variables are generated by the spread function.
# basically expand z_lkt to KT variables, filled with 0 if there is no data.
# I was using z_lkt, but it should be z_lk0?
# z_data &lt;- df |&gt; 
#   select(l,t,k,z_lkt) |&gt; 
#   mutate(k = str_glue(&quot;t{t}_sh_ind_{k}&quot;) ) |&gt;
#   spread(k, z_lkt, fill = 0)

z_data &lt;- df |&gt; 
  select(l,t,k,z_lk0) |&gt; 
  mutate(k = str_glue(&quot;t{t}_sh_ind_{k}&quot;) ) |&gt;
  spread(k, z_lk0, fill = 0)

Z &lt;- as.matrix(z_data[,-c(1,2)])

beta = round((t(Z) %*% Y)/(t(Z) %*% X), digits=3)
alpha=(diag(as.numeric(G)) %*% t(Z)  %*% X) / as.numeric((t(G) %*% t(Z) %*% X))

bw &lt;- tibble(g_kt, alpha=as.numeric(alpha), beta=as.numeric(beta)) |&gt; 
  mutate(product=alpha*beta)

bw</code></pre>
<pre><code>## # A tibble: 16 × 6
##        t     k     g_kt     alpha  beta   product
##    &lt;int&gt; &lt;int&gt;    &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;
##  1     1     1  0.130    0.0108   0.721  0.00777 
##  2     1     2  0.146    0.0194   1.16   0.0225  
##  3     1     3 -0.165    0.00963  0.802  0.00772 
##  4     1     4 -0.110    0.00714  1.08   0.00772 
##  5     2     1 -0.0289  -0.00801  0.878 -0.00703 
##  6     2     2 -0.00130 -0.000392 0.932 -0.000366
##  7     2     3  0.0433   0.0134   0.891  0.0120  
##  8     2     4  0.0840   0.0283   0.906  0.0257  
##  9     3     1 -0.101    0.137    0.989  0.136   
## 10     3     2 -0.152    0.221    0.988  0.219   
## 11     3     3 -0.0569   0.0755   0.986  0.0745  
## 12     3     4 -0.0994   0.136    0.995  0.135   
## 13     4     1  0.0266   0.0270   1.01   0.0273  
## 14     4     2  0.139    0.155    0.981  0.152   
## 15     4     3  0.0263   0.0268   1.01   0.0270  
## 16     4     4  0.127    0.141    1.01   0.143</code></pre>
<pre class="r"><code>sum(bw$product)</code></pre>
<pre><code>## [1] 0.9892878</code></pre>
<p>The sum of the product of <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\beta\)</span> should be the same as the Bartik estimator.</p>
<p>Note there is no restriction for <span class="math inline">\(\alpha\)</span>, other than the sum is 1. Therefore it can be negative or positive. It can be greater than 1, as long as the sum is 1. This probably needs to be restricted to be less than 1. But I am not sure about it.</p>
</div>
</div>
<div id="why-is-good-to-have-rotemberg-weights" class="section level1">
<h1>Why is good to have Rotemberg weights?</h1>
<p>GPSS Corollary D.1. shows the interpretation of the Rotemberg weights.</p>
<p>The percentage of bias can be writen as:</p>
<p><span class="math display">\[ \frac{E(\tilde{\beta})}{\beta} = \sum_k \alpha_k \frac{E(\tilde \beta_k)}{\beta_0}\]</span></p>
<p>This is to say the <span class="math inline">\(\alpha_k\)</span> is the share of the bias of the estimate of <span class="math inline">\(\beta\)</span> that comes from the bias of the estimate of <span class="math inline">\(\beta_k\)</span>. That is, how sensitive it is to the bias from industry <span class="math inline">\(k\)</span>.</p>
<p>In my simulations, all the industries are random, therefore the weights are random too. But in empirical studies, they are not random, most likely dominated by some industries. This is why it is important to have Rotemberg weights. It tells us which industries are important in the estimation of the effect of interest.</p>
</div>
<div id="what-if-you-are-using-a-reduced-form" class="section level1">
<h1>What if you are using a reduced form?</h1>
<p>If you use the reduced form, something like:</p>
<p><span class="math display">\[ y_{lt} = D_{lt} \rho + \beta_0 B_{lt} + \epsilon_{lt}\]</span></p>
<p>where <span class="math inline">\(B_{lt}\)</span> is the Bartik instrument, constructed in such as a way:</p>
<p><span class="math display">\[ B_{lt} = Z_{l0} G_{t} = \sum_{k=1}^K z_{lk0} g_{kt} \]</span></p>
<p>Then I think the Rotemberg weights should be calculated as:</p>
<p><span class="math display">\[ \beta_{Bartik} = \sum_{k} \hat \alpha_k \hat \beta_k\]</span>
where
<span class="math display">\[ \hat \beta_k = (Z&#39;_k B^{\perp})^{-1} Z&#39;_k Y^{\perp}\]</span>
and
<span class="math display">\[ \hat \alpha_k = \frac{g_k Z&#39;_k B^{\perp}}{\sum_{k&#39;} g_{k&#39;}  Z&#39;_{k&#39;} B^{\perp}}\]</span></p>
<p>where <span class="math inline">\(B^{\perp}\)</span> and <span class="math inline">\(Y^{\perp}\)</span> are residualized <span class="math inline">\(B\)</span> and <span class="math inline">\(Y\)</span>.</p>
<pre class="r"><code>result_reduced &lt;- df_lt |&gt;
  lm(formula = y_lt ~  b_lt)

modelsummary::modelsummary(result_reduced)</code></pre>
<!-- preamble start -->

    <script>
      function styleCell_21a8z5dpa5v4rgc8q9v8(i, j, css_id) {
        var table = document.getElementById("tinytable_21a8z5dpa5v4rgc8q9v8");
        table.rows[i].cells[j].classList.add(css_id);
      }
      function insertSpanRow(i, colspan, content) {
        var table = document.getElementById('tinytable_21a8z5dpa5v4rgc8q9v8');
        var newRow = table.insertRow(i);
        var newCell = newRow.insertCell(0);
        newCell.setAttribute("colspan", colspan);
        // newCell.innerText = content;
        // this may be unsafe, but innerText does not interpret <br>
        newCell.innerHTML = content;
      }
      function spanCell_21a8z5dpa5v4rgc8q9v8(i, j, rowspan, colspan) {
        var table = document.getElementById("tinytable_21a8z5dpa5v4rgc8q9v8");
        const targetRow = table.rows[i];
        const targetCell = targetRow.cells[j];
        for (let r = 0; r < rowspan; r++) {
          // Only start deleting cells to the right for the first row (r == 0)
          if (r === 0) {
            // Delete cells to the right of the target cell in the first row
            for (let c = colspan - 1; c > 0; c--) {
              if (table.rows[i + r].cells[j + c]) {
                table.rows[i + r].deleteCell(j + c);
              }
            }
          }
          // For rows below the first, delete starting from the target column
          if (r > 0) {
            for (let c = colspan - 1; c >= 0; c--) {
              if (table.rows[i + r] && table.rows[i + r].cells[j]) {
                table.rows[i + r].deleteCell(j);
              }
            }
          }
        }
        // Set rowspan and colspan of the target cell
        targetCell.rowSpan = rowspan;
        targetCell.colSpan = colspan;
      }
window.addEventListener('load', function () { styleCell_21a8z5dpa5v4rgc8q9v8(0, 0, 'tinytable_css_idfe6g22pgoorvhwiq5mx9') })
window.addEventListener('load', function () { styleCell_21a8z5dpa5v4rgc8q9v8(0, 1, 'tinytable_css_id4w05cxtp1ykfxtvasqw5') })
window.addEventListener('load', function () { styleCell_21a8z5dpa5v4rgc8q9v8(1, 0, 'tinytable_css_idlqou2aata3gc5t9gtveu') })
window.addEventListener('load', function () { styleCell_21a8z5dpa5v4rgc8q9v8(1, 1, 'tinytable_css_id5qmfbm04c4fmpsytr3sf') })
window.addEventListener('load', function () { styleCell_21a8z5dpa5v4rgc8q9v8(2, 0, 'tinytable_css_idlqou2aata3gc5t9gtveu') })
window.addEventListener('load', function () { styleCell_21a8z5dpa5v4rgc8q9v8(2, 1, 'tinytable_css_id5qmfbm04c4fmpsytr3sf') })
window.addEventListener('load', function () { styleCell_21a8z5dpa5v4rgc8q9v8(3, 0, 'tinytable_css_idlqou2aata3gc5t9gtveu') })
window.addEventListener('load', function () { styleCell_21a8z5dpa5v4rgc8q9v8(3, 1, 'tinytable_css_id5qmfbm04c4fmpsytr3sf') })
window.addEventListener('load', function () { styleCell_21a8z5dpa5v4rgc8q9v8(4, 0, 'tinytable_css_idwssqertzk1xpg991gdcv') })
window.addEventListener('load', function () { styleCell_21a8z5dpa5v4rgc8q9v8(4, 1, 'tinytable_css_idixedy1cw9ljzitlz5qi8') })
window.addEventListener('load', function () { styleCell_21a8z5dpa5v4rgc8q9v8(5, 0, 'tinytable_css_idlqou2aata3gc5t9gtveu') })
window.addEventListener('load', function () { styleCell_21a8z5dpa5v4rgc8q9v8(5, 1, 'tinytable_css_id5qmfbm04c4fmpsytr3sf') })
window.addEventListener('load', function () { styleCell_21a8z5dpa5v4rgc8q9v8(6, 0, 'tinytable_css_idlqou2aata3gc5t9gtveu') })
window.addEventListener('load', function () { styleCell_21a8z5dpa5v4rgc8q9v8(6, 1, 'tinytable_css_id5qmfbm04c4fmpsytr3sf') })
window.addEventListener('load', function () { styleCell_21a8z5dpa5v4rgc8q9v8(7, 0, 'tinytable_css_idlqou2aata3gc5t9gtveu') })
window.addEventListener('load', function () { styleCell_21a8z5dpa5v4rgc8q9v8(7, 1, 'tinytable_css_id5qmfbm04c4fmpsytr3sf') })
window.addEventListener('load', function () { styleCell_21a8z5dpa5v4rgc8q9v8(8, 0, 'tinytable_css_idlqou2aata3gc5t9gtveu') })
window.addEventListener('load', function () { styleCell_21a8z5dpa5v4rgc8q9v8(8, 1, 'tinytable_css_id5qmfbm04c4fmpsytr3sf') })
window.addEventListener('load', function () { styleCell_21a8z5dpa5v4rgc8q9v8(9, 0, 'tinytable_css_idlqou2aata3gc5t9gtveu') })
window.addEventListener('load', function () { styleCell_21a8z5dpa5v4rgc8q9v8(9, 1, 'tinytable_css_id5qmfbm04c4fmpsytr3sf') })
window.addEventListener('load', function () { styleCell_21a8z5dpa5v4rgc8q9v8(10, 0, 'tinytable_css_idlqou2aata3gc5t9gtveu') })
window.addEventListener('load', function () { styleCell_21a8z5dpa5v4rgc8q9v8(10, 1, 'tinytable_css_id5qmfbm04c4fmpsytr3sf') })
window.addEventListener('load', function () { styleCell_21a8z5dpa5v4rgc8q9v8(11, 0, 'tinytable_css_idlqou2aata3gc5t9gtveu') })
window.addEventListener('load', function () { styleCell_21a8z5dpa5v4rgc8q9v8(11, 1, 'tinytable_css_id5qmfbm04c4fmpsytr3sf') })
window.addEventListener('load', function () { styleCell_21a8z5dpa5v4rgc8q9v8(12, 0, 'tinytable_css_idlqou2aata3gc5t9gtveu') })
window.addEventListener('load', function () { styleCell_21a8z5dpa5v4rgc8q9v8(12, 1, 'tinytable_css_id5qmfbm04c4fmpsytr3sf') })
    </script>

    <style>
    .table td.tinytable_css_idfe6g22pgoorvhwiq5mx9, .table th.tinytable_css_idfe6g22pgoorvhwiq5mx9 {  text-align: left;  border-bottom: solid 0.1em #d3d8dc; }
    .table td.tinytable_css_id4w05cxtp1ykfxtvasqw5, .table th.tinytable_css_id4w05cxtp1ykfxtvasqw5 {  text-align: center;  border-bottom: solid 0.1em #d3d8dc; }
    .table td.tinytable_css_idlqou2aata3gc5t9gtveu, .table th.tinytable_css_idlqou2aata3gc5t9gtveu {  text-align: left; }
    .table td.tinytable_css_id5qmfbm04c4fmpsytr3sf, .table th.tinytable_css_id5qmfbm04c4fmpsytr3sf {  text-align: center; }
    .table td.tinytable_css_idwssqertzk1xpg991gdcv, .table th.tinytable_css_idwssqertzk1xpg991gdcv {  border-bottom: solid 0.05em black;  text-align: left; }
    .table td.tinytable_css_idixedy1cw9ljzitlz5qi8, .table th.tinytable_css_idixedy1cw9ljzitlz5qi8 {  border-bottom: solid 0.05em black;  text-align: center; }
    </style>
    <div class="container">
      <table class="table table-borderless" id="tinytable_21a8z5dpa5v4rgc8q9v8" style="width: auto; margin-left: auto; margin-right: auto;" data-quarto-disable-processing='true'>
        <thead>
        
              <tr>
                <th scope="col"> </th>
                <th scope="col">(1)</th>
              </tr>
        </thead>
        
        <tbody>
                <tr>
                  <td>(Intercept)</td>
                  <td>-0.001  </td>
                </tr>
                <tr>
                  <td>           </td>
                  <td>(0.002) </td>
                </tr>
                <tr>
                  <td>b_lt       </td>
                  <td>0.909   </td>
                </tr>
                <tr>
                  <td>           </td>
                  <td>(0.023) </td>
                </tr>
                <tr>
                  <td>Num.Obs.   </td>
                  <td>4000    </td>
                </tr>
                <tr>
                  <td>R2         </td>
                  <td>0.278   </td>
                </tr>
                <tr>
                  <td>R2 Adj.    </td>
                  <td>0.278   </td>
                </tr>
                <tr>
                  <td>AIC        </td>
                  <td>-6730.0 </td>
                </tr>
                <tr>
                  <td>BIC        </td>
                  <td>-6711.1 </td>
                </tr>
                <tr>
                  <td>Log.Lik.   </td>
                  <td>3367.980</td>
                </tr>
                <tr>
                  <td>F          </td>
                  <td>1538.779</td>
                </tr>
                <tr>
                  <td>RMSE       </td>
                  <td>0.10    </td>
                </tr>
        </tbody>
      </table>
    </div>
<!-- hack to avoid NA insertion in last line -->
<p>Now we calculate the Rotemberg weights for the reduced form, for our simulated data.</p>
<pre class="r"><code>B &lt;- as.matrix(b_lt[,3])

beta = (t(Z) %*% Y)/(t(Z) %*% B)
alpha=(diag(as.numeric(G)) %*% t(Z)  %*% B) / as.numeric((t(G) %*% t(Z) %*% B))

bw &lt;- tibble(g_kt, alpha=as.numeric(alpha), beta=as.numeric(beta)) |&gt; 
  mutate(product = alpha * beta)

bw</code></pre>
<pre><code>## # A tibble: 16 × 6
##        t     k     g_kt     alpha  beta   product
##    &lt;int&gt; &lt;int&gt;    &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;
##  1     1     1  0.130    0.0233   0.307  0.00714 
##  2     1     2  0.146    0.0302   0.686  0.0207  
##  3     1     3 -0.165    0.0304   0.233  0.00710 
##  4     1     4 -0.110    0.0128   0.553  0.00710 
##  5     2     1 -0.0289  -0.00660  0.979 -0.00646 
##  6     2     2 -0.00130 -0.000359 0.937 -0.000336
##  7     2     3  0.0433   0.0137   0.803  0.0110  
##  8     2     4  0.0840   0.0313   0.753  0.0236  
##  9     3     1 -0.101    0.127    0.985  0.125   
## 10     3     2 -0.152    0.209    0.961  0.201   
## 11     3     3 -0.0569   0.0681   1.01   0.0685  
## 12     3     4 -0.0994   0.126    0.990  0.124   
## 13     4     1  0.0266   0.0243   1.03   0.0250  
## 14     4     2  0.139    0.154    0.909  0.140   
## 15     4     3  0.0263   0.0241   1.03   0.0248  
## 16     4     4  0.127    0.134    0.979  0.131</code></pre>
<pre class="r"><code>sum(bw$product)</code></pre>
<pre><code>## [1] 0.9089352</code></pre>
</div>
